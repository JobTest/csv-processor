
Неизменяемые типы данных или Тип-сумма (следующих альтернативных реализаций или алгебраические типы данных)
--------------------------------------

    `sealed` - В Scala есть алгебраические типы данных (Algebraic Data Types `ADT`) - идиоматичный способ создания перечислений
    (Они часто используются для обеспечения альтернативы Enum)


```scala
    // Мы получаем перечисление свободное от привязки к каким либо константам а также проверку на полноту сопоставления с образцом...
    sealed trait TrafficLight
    case object Green extends TrafficLight
    case object Yellow extends TrafficLight
    case object Red extends TrafficLight
    case object Broken extends TrafficLight
``` 

Классы типов
------------

* Скрытые классы (неявные классы `implicit`) – такие классы позволяют делать неявное обращение к первичному конструктору если класс находится в области его видимости...

* При работе со скрытыми классами стоит учитывать следующее:
  - Скрытые классы (`implicit`) должны быть объявлены внутри другого класса, объекта или кортеджа (`trait`)
  - Скрытый класс (`implicit`) может принимать только один не скрытый аргумент и конструктор
  -
  - должны быть определены внутри другого класса или объекта;
  - имя класса должно быть уникально в рамках его области видимости;
  - не может быть case-классом;
  - класс может принимать только один не implicit аргумент.

    Например:
    Пусть в интересующем нас алгоритме используется сравнение данных по порядку. 
    мы бы хотели внутри алгоритма сравнивать объекты с помощью метода `a.compare(b)` без явного вызова метода класса типа.
    (Для этого используется обычный в Scala механизм pimp-my-library)


* https://proselyte.net/tutorials/scala/classes-and-objects | https://habr.com/post/318960 | https://www.oreilly.com/library/view/learning-scala/9781449368814/ch10.html | http://bavadim.me/programming/2015/02/07/Notes-about-FP.html

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Предположим, мы реализовали некоторый алгоритм вне наших типов данных. Если в этом алгоритме прямо используются наши типы, то мы не сможем его использовать повторно для других похожих данных.
Поэтому хотелось бы иметь механизмы, позволяющие обобщить наш алгоритм на другие типы данных (существующие и перспективные). Это позволит использовать тот же алгоритм во многих случаях и окупит затраты на его разработку и тестирование.
